from fastapi import FastAPI, Request, HTTPException, Depends
from fastapi.middleware.cors import CORSMiddleware
import os
import json
import hashlib
import hmac
import time
from typing import Optional, Dict, Any, List
import logging
from pydantic import BaseModel
from telegram import Bot, Update, InlineKeyboardButton, InlineKeyboardMarkup, WebAppInfo
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    filters,
    ContextTypes,
    CallbackQueryHandler
)

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# –ü–æ–ª—É—á–∞–µ–º —Ç–æ–∫–µ–Ω –±–æ—Ç–∞ –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
TELEGRAM_BOT_TOKEN = os.environ.get("TELEGRAM_BOT_TOKEN")
if not TELEGRAM_BOT_TOKEN:
    raise ValueError("–ù–µ–æ–±—Ö–æ–¥–∏–º–æ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –æ–∫—Ä—É–∂–µ–Ω–∏—è TELEGRAM_BOT_TOKEN")

# URL –≤–∞—à–µ–≥–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è, —Ä–∞–∑–≤–µ—Ä–Ω—É—Ç–æ–≥–æ –Ω–∞ —Ö–æ—Å—Ç–∏–Ω–≥–µ
WEBAPP_URL = os.environ.get("WEBAPP_URL", "https://example.com/app")

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è FastAPI
app = FastAPI(title="Notes Manager Bot API")

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # –í –ø—Ä–æ–¥–∞–∫—à–µ–Ω–µ –∑–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ –¥–æ–º–µ–Ω—ã
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# –ú–æ–¥–µ–ª–∏ –¥–∞–Ω–Ω—ã—Ö
class WebAppData(BaseModel):
    user_id: int
    action: str
    data: Dict[str, Any]

class TelegramInitData(BaseModel):
    data: str
    
class ApiResponse(BaseModel):
    success: bool
    message: str
    data: Optional[Dict[str, Any]] = None

# –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
def validate_telegram_data(init_data: str, bot_token: str) -> bool:
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å –¥–∞–Ω–Ω—ã—Ö, –ø–æ–ª—É—á–µ–Ω–Ω—ã—Ö –æ—Ç Telegram Web App
    –ü–æ–¥—Ä–æ–±–Ω–µ–µ: https://core.telegram.org/bots/webapps#validating-data-received-via-the-web-app
    """
    try:
        # –†–∞–∑–±–∏—Ä–∞–µ–º —Å—Ç—Ä–æ–∫—É init_data –Ω–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
        data_dict = dict(param.split('=') for param in init_data.split('&'))
        
        # –ò–∑–≤–ª–µ–∫–∞–µ–º —Ö–µ—à –∏–∑ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
        received_hash = data_dict.pop('hash', None)
        if not received_hash:
            logger.error("Hash is missing from init_data")
            return False
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω–∞—è —Å—Ç—Ä–æ–∫–∞ —Å–æ–¥–µ—Ä–∂–∏—Ç —Ç–æ–ª—å–∫–æ —Ä–∞–∑—Ä–µ—à–µ–Ω–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã
        if not all(c in "0123456789abcdef" for c in received_hash):
            logger.error("Hash contains invalid characters")
            return False
        
        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –æ—Å—Ç–∞–≤—à–∏–µ—Å—è –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤ –∞–ª—Ñ–∞–≤–∏—Ç–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ
        data_check_string = '\n'.join(f'{key}={value}' for key, value in sorted(data_dict.items()))
        
        # –°–æ–∑–¥–∞–µ–º —Å–µ–∫—Ä–µ—Ç–Ω—ã–π –∫–ª—é—á
        secret_key = hmac.new(
            key=b"WebAppData",
            msg=bot_token.encode(),
            digestmod=hashlib.sha256
        ).digest()
        
        # –°–æ–∑–¥–∞–µ–º HMAC-SHA-256 –ø–æ–¥–ø–∏—Å—å
        generated_hash = hmac.new(
            key=secret_key,
            msg=data_check_string.encode(),
            digestmod=hashlib.sha256
        ).hexdigest()
        
        # –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º –ø–æ–ª—É—á–µ–Ω–Ω—ã–π —Ö–µ—à —Å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–º
        return hmac.compare_digest(received_hash, generated_hash)
    except Exception as e:
        logger.error(f"Error validating Telegram init data: {e}")
        return False

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–æ–º–∞–Ω–¥ –±–æ—Ç–∞
async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ –º–µ–Ω—é –ø—Ä–∏ –∫–æ–º–∞–Ω–¥–µ /start."""
    user = update.effective_user
    
    # –°–æ–∑–¥–∞–µ–º –∫–Ω–æ–ø–∫—É –¥–ª—è –∑–∞–ø—É—Å–∫–∞ –≤–µ–±-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
    keyboard = [
        [InlineKeyboardButton(
            "üìù –û—Ç–∫—Ä—ã—Ç—å Notes Manager", 
            web_app=WebAppInfo(url=f"{WEBAPP_URL}")
        )]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_html(
        f"–ü—Ä–∏–≤–µ—Ç, {user.mention_html()}! üëã\n\n"
        f"–Ø –±–æ—Ç –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –∑–∞–º–µ—Ç–∫–∞–º–∏ Notes Manager.\n"
        f"–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ, —á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ.",
        reply_markup=reply_markup
    )

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–æ–º–∞–Ω–¥–∞—Ö –±–æ—Ç–∞."""
    keyboard = [
        [InlineKeyboardButton(
            "üìù –û—Ç–∫—Ä—ã—Ç—å Notes Manager", 
            web_app=WebAppInfo(url=f"{WEBAPP_URL}")
        )]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(
        "–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n"
        "/start - –ù–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É —Å –±–æ—Ç–æ–º\n"
        "/help - –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç—É —Å–ø—Ä–∞–≤–∫—É\n"
        "/notes - –ü–æ–∫–∞–∑–∞—Ç—å —Å–ø–∏—Å–æ–∫ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –∑–∞–º–µ—Ç–æ–∫\n"
        "/new - –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é –∑–∞–º–µ—Ç–∫—É\n\n"
        "–ò–ª–∏ –Ω–∞–∂–º–∏—Ç–µ –Ω–∞ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ, —á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ:",
        reply_markup=reply_markup
    )

async def notes_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –∑–∞–º–µ—Ç–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è."""
    user_id = update.effective_user.id
    
    # –ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏, –≤ —Ä–µ–∞–ª—å–Ω–æ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ –∑–¥–µ—Å—å –±—É–¥–µ—Ç –∑–∞–ø—Ä–æ—Å –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
    # –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö –æ –∑–∞–º–µ—Ç–∫–∞—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    keyboard = [
        [InlineKeyboardButton(
            "üìù –ü—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å –≤—Å–µ –∑–∞–º–µ—Ç–∫–∏", 
            web_app=WebAppInfo(url=f"{WEBAPP_URL}")
        )]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(
        "–í–∞—à–∏ –ø–æ—Å–ª–µ–¥–Ω–∏–µ –∑–∞–º–µ—Ç–∫–∏:\n\n"
        "üîπ –î–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ –ø–æ–ª–Ω–æ–º—É —Å–ø–∏—Å–∫—É –∑–∞–º–µ—Ç–æ–∫ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ:",
        reply_markup=reply_markup
    )

async def new_note_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """–ö–æ–º–∞–Ω–¥–∞ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –Ω–æ–≤–æ–π –∑–∞–º–µ—Ç–∫–∏."""
    keyboard = [
        [InlineKeyboardButton(
            "üìù –°–æ–∑–¥–∞—Ç—å –∑–∞–º–µ—Ç–∫—É", 
            web_app=WebAppInfo(url=f"{WEBAPP_URL}?create=new")
        )]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(
        "–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ, —á—Ç–æ–±—ã —Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é –∑–∞–º–µ—Ç–∫—É:",
        reply_markup=reply_markup
    )

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ–±—ã—á–Ω—ã—Ö —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π."""
    if update.message.text:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –º–æ–∂–µ—Ç –±—ã—Ç—å —ç—Ç–æ –∫–æ–º–∞–Ω–¥–∞ –ø–æ–∏—Å–∫–∞ –ø–æ –∑–∞–º–µ—Ç–∫–∞–º
        if update.message.text.startswith("–Ω–∞–π—Ç–∏ ") or update.message.text.startswith("–ø–æ–∏—Å–∫ "):
            query = update.message.text.split(" ", 1)[1]
            await search_notes(update, query)
        else:
            await help_command(update, context)

async def search_notes(update: Update, query: str) -> None:
    """–§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–∏—Å–∫–∞ –∑–∞–º–µ—Ç–æ–∫ –ø–æ –∑–∞–ø—Ä–æ—Å—É."""
    keyboard = [
        [InlineKeyboardButton(
            "üìù –û—Ç–∫—Ä—ã—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ–∏—Å–∫–∞", 
            web_app=WebAppInfo(url=f"{WEBAPP_URL}?search={query}")
        )]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(
        f"–î–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –ø–æ–∏—Å–∫–∞ –ø–æ –∑–∞–ø—Ä–æ—Å—É \"{query}\"\n"
        f"–Ω–∞–∂–º–∏—Ç–µ –Ω–∞ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ:",
        reply_markup=reply_markup
    )

async def handle_webapp_data(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–∞–Ω–Ω—ã—Ö, –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã—Ö –∏–∑ –≤–µ–±-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è."""
    # –î–∞–Ω–Ω—ã–µ –∏–∑ –≤–µ–±-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –ø—Ä–∏—Ö–æ–¥—è—Ç –≤ –≤–∏–¥–µ JSON —Å—Ç—Ä–æ–∫–∏
    if not update.message.web_app_data:
        return
    
    try:
        # –†–∞–∑–±–∏—Ä–∞–µ–º –ø–æ–ª—É—á–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
        data = json.loads(update.message.web_app_data.data)
        action = data.get("action", "")
        
        if action == "note_created":
            # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–±—ã—Ç–∏—è —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–º–µ—Ç–∫–∏
            note_name = data.get("note_name", "")
            await update.message.reply_text(f"‚úÖ –ó–∞–º–µ—Ç–∫–∞ '{note_name}' —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞!")
            
        elif action == "note_updated":
            # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–±—ã—Ç–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∑–∞–º–µ—Ç–∫–∏
            note_name = data.get("note_name", "")
            await update.message.reply_text(f"‚úÖ –ó–∞–º–µ—Ç–∫–∞ '{note_name}' —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∞!")
            
        elif action == "note_deleted":
            # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–±—ã—Ç–∏—è —É–¥–∞–ª–µ–Ω–∏—è –∑–∞–º–µ—Ç–∫–∏
            note_name = data.get("note_name", "")
            await update.message.reply_text(f"üóëÔ∏è –ó–∞–º–µ—Ç–∫–∞ '{note_name}' —É–¥–∞–ª–µ–Ω–∞!")
            
        else:
            # –ï—Å–ª–∏ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ–±—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
            await update.message.reply_text("‚úÖ –û–ø–µ—Ä–∞—Ü–∏—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ!")
            
    except json.JSONDecodeError:
        await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–∞–Ω–Ω—ã—Ö –∏–∑ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è.")
    except Exception as e:
        logger.error(f"Error handling webapp data: {e}")
        await update.message.reply_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∑–∞–ø—Ä–æ—Å–∞.")

# API endpoints –¥–ª—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å –≤–µ–±-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ–º
@app.post("/api/telegram/validate", response_model=ApiResponse)
async def validate_telegram_init_data(data: TelegramInitData):
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å –¥–∞–Ω–Ω—ã—Ö –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –æ—Ç Telegram Web App."""
    try:
        if validate_telegram_data(data.data, TELEGRAM_BOT_TOKEN):
            return {"success": True, "message": "–î–∞–Ω–Ω—ã–µ –≤–∞–ª–∏–¥–Ω—ã", "data": None}
        else:
            raise HTTPException(status_code=403, detail="–ù–µ–≤–∞–ª–∏–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏")
    except Exception as e:
        logger.error(f"Error validating init data: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/telegram/webapp-data", response_model=ApiResponse)
async def receive_webapp_data(data: WebAppData):
    """–ü–æ–ª—É—á–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –æ—Ç –≤–µ–±-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –∏ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∏—Ö."""
    try:
        user_id = data.user_id
        action = data.action
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é —á–µ—Ä–µ–∑ –±–æ—Ç–∞
        bot = Bot(token=TELEGRAM_BOT_TOKEN)
        
        if action == "note_created":
            # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–º–µ—Ç–∫–∏
            note_name = data.data.get("note_name", "")
            await bot.send_message(
                chat_id=user_id,
                text=f"‚úÖ –ó–∞–º–µ—Ç–∫–∞ '{note_name}' —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞!"
            )
        
        elif action == "note_updated":
            # –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∑–∞–º–µ—Ç–∫–∏
            note_name = data.data.get("note_name", "")
            await bot.send_message(
                chat_id=user_id,
                text=f"‚úÖ –ó–∞–º–µ—Ç–∫–∞ '{note_name}' —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∞!"
            )
        
        elif action == "note_deleted":
            # –û–±—Ä–∞–±–æ—Ç–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –∑–∞–º–µ—Ç–∫–∏
            note_name = data.data.get("note_name", "")
            await bot.send_message(
                chat_id=user_id,
                text=f"üóëÔ∏è –ó–∞–º–µ—Ç–∫–∞ '{note_name}' —É–¥–∞–ª–µ–Ω–∞!"
            )
        
        else:
            # –û–±—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã—Ö –¥–µ–π—Å—Ç–≤–∏–π
            await bot.send_message(
                chat_id=user_id,
                text="‚úÖ –û–ø–µ—Ä–∞—Ü–∏—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ!"
            )
        
        return {"success": True, "message": "–î–∞–Ω–Ω—ã–µ —É—Å–ø–µ—à–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω—ã", "data": None}
    
    except Exception as e:
        logger.error(f"Error processing webapp data: {e}")
        return {"success": False, "message": f"–û—à–∏–±–∫–∞: {str(e)}", "data": None}

# –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –º–µ—Ç–æ–¥ run_bot –ø—Ä–∞–≤–∏–ª—å–Ω–æ —Ä–∞–±–æ—Ç–∞–µ—Ç —Å –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–º–∏ —Ñ—É–Ω–∫—Ü–∏—è–º–∏

async def run_bot():
    """–ó–∞–ø—É—Å–∫–∞–µ—Ç Telegram –±–æ—Ç–∞."""
    try:
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–∫–µ–Ω –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
        application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
        
        # –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤
        application.add_handler(CommandHandler("start", start_command))
        application.add_handler(CommandHandler("help", help_command))
        application.add_handler(CommandHandler("notes", notes_command))
        application.add_handler(CommandHandler("new", new_note_command))
        application.add_handler(MessageHandler(filters.StatusUpdate.WEB_APP_DATA, handle_webapp_data))
        application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
        
        # –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ –±–µ–∑ –æ–∂–∏–¥–∞–Ω–∏—è - –ø—Ä–æ—Å—Ç–æ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        await application.initialize()
        await application.start()
        return application
    except Exception as e:
        logger.error(f"Error starting bot: {e}")
        return None

# –ï—Å–ª–∏ —Ñ–∞–π–ª –∑–∞–ø—É—â–µ–Ω –Ω–∞–ø—Ä—è–º—É—é
if __name__ == "__main__":
    import asyncio
    asyncio.run(run_bot())
